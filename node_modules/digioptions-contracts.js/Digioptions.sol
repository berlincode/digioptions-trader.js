/*
 Contract used by digioptions.com

 Copyright (c) frenchhoudini (https://github.com/frenchhoudini/etheropt)
 Copyright (c) digioptions.com (http://www.digioptions.com) 

 This contract is derived from:

 https://github.com/etheropt/etheropt.github.io/blob/619f394c9cb91becdc7bc1a2a39582d41abeb6b6/etheropt.sol
 and
 https://github.com/etheropt/etheropt.github.io/blob/619f394c9cb91becdc7bc1a2a39582d41abeb6b6/etheropt_contracts.sol

 License: MIT
*/

pragma solidity ^0.4.11;


contract DigioptionsContracts {

    /* we use a simple linked list to sort contracts by expiration date */
    struct Element {
        address previous;
        bool hasPrevious;
        bool enabled;
        uint expiration;
    }

    address public owner;

    Element public head; /* we use only head.previous */
    mapping(address => Element) elements;

    /* This is the constructor */
    function DigioptionsContracts () {
        owner = msg.sender;
    }

    function newContract (address addr) {
        Element element = head;
        Element previous = elements[element.previous];

        if (msg.sender != owner)
            throw;

        /* Check that the addr is not already taken. Since we do not allow an */
        /* expiration of 0 we can use this field to verify against null */
        if (elements[addr].expiration != 0)
            throw;

        uint expiration = DigioptionsMarket(addr).expiration();
        if (expiration == 0)
            throw;

        /* find the right place to insert */
        while (previous.expiration > expiration) {
            element = previous;
            previous = elements[element.previous];
        }

        /* insert */
        elements[addr] = Element(
            element.previous, /* address previous */
            previous.expiration > 0, /* bool hasPrevious */
            true, /* bool enabled */
            expiration /* uint expiration */
        );
        element.previous = addr;
        element.hasPrevious = true;
    }

    function getContractsAllCursor (bool returnDisabled, uint expiration, Element element) constant internal returns (address[]) {
        address[] memory addrs = new address[](20);
        uint z = 0;

        /* TODO following line (last part) is not lintable via solium */
        while ((z < 20) && (element.hasPrevious) && (elements[element.previous].expiration >= expiration)) {
            if (returnDisabled || elements[element.previous].enabled) {
                addrs[z] = element.previous;
                z++;
            }
            element = elements[element.previous];
        }
        return addrs;
    }

    function getContracts (bool returnDisabled, uint expiration) constant returns(address[]) {
        return getContractsAllCursor(returnDisabled, expiration, head);
    }

    function getContractsNext (bool returnDisabled, uint expiration, address cursor) constant returns(address[]) {
        return getContractsAllCursor(returnDisabled, expiration, elements[cursor]);
    }

    function disableContract (address addr) {
        if (msg.sender != owner)
            throw;

        elements[addr].enabled = false;
    }

}


contract DigioptionsMarket {

    struct Position {
        mapping(uint => int) positions;
        int cash;
        bool expired;
        bool hasPosition;
    }
    uint public expiration;
    string public underlying; /* just info */
    uint public margin;
    uint public realityID;
    bytes32 public factHash;
    address public ethAddr;
    mapping(uint => int) options;
    uint public numOptions;
    bool public expired;
    mapping(address => Position) positions;
    uint public numPositions;
    uint public numPositionsExpired;
    struct Account {
        address user;
        int capital;
    }
    mapping(bytes32 => int) orderFills; //keeps track of cumulative order fills
    mapping(uint => Account) accounts;
    uint public numAccounts;
    mapping(address => uint) accountIDs; //starts at 1

    //events
    event Deposit(address indexed user, uint amount, int balance); //balance is balance after deposit
    event Withdraw(address indexed user, uint amount, int balance); //balance is balance after withdraw
    event Expire(address indexed caller, address indexed user); //user is the account that was expired
    event OrderMatchFailure(address indexed matchUser, int matchSize, address indexed orderUser, int orderSize, uint optionID, uint price);
    event OrderMatch(address indexed matchUser, int matchSize, address indexed orderUser, int orderSize, uint optionID, uint price);

    // This is the constructor
    function DigioptionsMarket (
        uint expiration_,
        string underlying_,
        uint margin_,
        uint realityID_,
        bytes32 factHash_,
        address ethAddr_,
        int[] strikes_
    ) {

        expiration = expiration_;
        underlying = underlying_;
        margin = margin_;
        realityID = realityID_;
        factHash = factHash_;
        ethAddr = ethAddr_;
        for (uint i = 0; i < strikes_.length; i++) {
            uint optionID = numOptions++;
            options[optionID] = strikes_[i];
        }
    }

    function addFundsInternal () internal {
        if (accountIDs[msg.sender] > 0) {
            accounts[accountIDs[msg.sender]].capital += int(msg.value);
        } else {
            uint accountID = ++numAccounts;
            accounts[accountID].user = msg.sender;
            accounts[accountID].capital += int(msg.value);
            accountIDs[msg.sender] = accountID;
        }
        Deposit(msg.sender, msg.value, accounts[accountIDs[msg.sender]].capital);
    }

    function addFunds () payable {
        addFundsInternal();
    }

    function withdrawFunds (uint amount) returns(bool) {
        if (accountIDs[msg.sender] > 0) {
            if (int(amount) <= getFunds(msg.sender, true) && int(amount) > 0) {
                /* Remember to reduce the capital BEFORE */
                /* sending to prevent re-entrancy attacks */
                accounts[accountIDs[msg.sender]].capital -= int(amount);
                if (msg.sender.send(amount)) {
                    Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital);
                    return true;
                } else {
                    accounts[accountIDs[msg.sender]].capital += int(amount);
                }
            }
        }
        return false;
    }

    function getFunds (address user, bool onlyAvailable) constant returns(int) {
        if (accountIDs[user] > 0) {
            if (onlyAvailable == false) {
                return accounts[accountIDs[user]].capital;
            } else {
                return ( 
                    accounts[accountIDs[user]].capital +
                    getMaxLossAfterTrade(
                        user,
                        0,
                        0,
                        0
                    )
                );
            }
        } else {
            return 0;
        }
    }

    function getFundsAndAvailable (address user) constant returns(int, int) {
        return (getFunds(user, false), getFunds(user, true));
    }

    function getOptionChain () constant returns (uint, string, uint, uint, bytes32, address) {
        return (expiration, underlying, margin, realityID, factHash, ethAddr);
    }

    function getMarket (address user) constant returns (uint[], int[], int[], int[]) {
        uint[] memory optionIDs = new uint[](numOptions);
        int[] memory strikes_ = new int[](numOptions);
        int[] memory positions_ = new int[](numOptions);
        int[] memory cashes = new int[](numOptions);
        if (expired == false) {
            for (uint optionID = 0; optionID < numOptions; optionID++) {
                optionIDs[optionID] = optionID;
                strikes_[optionID] = options[optionID];
                // following the user dependent data
                positions_[optionID] = positions[user].positions[optionID];
                cashes[optionID] = positions[user].cash;
            }
        }
        return (optionIDs, strikes_, positions_, cashes);
    }

    function expire (
        uint8 v,
        bytes32 r,
        bytes32 s,
        bytes32 
        value
    ) {
        if (expired == false) {
            if (
                    ecrecover(
                        sha3(factHash, value),
                        v,
                        r,
                        s
                    ) == ethAddr
                ) {
                for (uint accountID = 0; accountID <= numAccounts; accountID++) {
                    if (positions[accounts[accountID].user].expired == false) {
                        int result = positions[accounts[accountID].user].cash / 1000000000000000000;
                        for (uint optionID = 0; optionID < numOptions; optionID++) {
                            int moneyness = getMoneyness(options[optionID], uint(value), margin);
                            result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;
                        }
                        positions[accounts[accountID].user].expired = true;
                        uint amountToSend = uint(accounts[accountID].capital + result);
                        accounts[accountID].capital = 0;
                        if (positions[accounts[accountID].user].hasPosition == true) {
                            numPositionsExpired++;
                        }
                        // TODO: dangerous?
                        // TODO: Warning: Return value of low-level calls not used
                        accounts[accountID].user.call.value(amountToSend)();
                        Expire(msg.sender, accounts[accountID].user);
                    }
                }
                if (numPositionsExpired == numPositions) {
                    expired = true;
                }
            }
        }
    }

    function getMoneyness (int strike, uint settlement, uint margin) constant returns (int) {
        if (strike >= 0) { //call
            if (settlement > uint(strike)) {
                if (settlement-uint(strike)<margin) {
                    return int(settlement-uint(strike));
                } else {
                    return int(margin);
                }
            } else {
                return 0;
            }
        } else { //put
            if (settlement<uint(-strike)) {
                if (uint(-strike)-settlement<margin) {
                    return int(uint(-strike)-settlement);
                } else {
                    return int(margin);
                }
            } else {
                return 0;
            }
        }
    }

    function orderMatchTest (
        uint optionID,
        uint price,
        int size,
        uint orderID,
        uint blockExpires,
        address addr,
        address sender,
        uint value,
        int matchSize
    ) constant returns (bool)
    {
// sha3 is cheapest
        bytes32 hash = sha256(
            optionID,
            price,
            size,
            orderID,
            blockExpires
        );
//        bytes32 hash = sha3(optionID, price, size, orderID, blockExpires);
        if (
                (block.number <= blockExpires) && 
                (
                    ((size > 0) && (matchSize < 0) && (orderFills[hash]-matchSize <= size))||
                    ((size < 0) && (matchSize > 0) && (orderFills[hash]-matchSize >= size))
                ) && 
                (
                    getFunds(addr, false) +
                    getMaxLossAfterTrade(
                        addr,
                        optionID,
                        -matchSize,
                        matchSize * int(price)
                    ) > 0
                ) &&
                (
                    getFunds(sender, false) +
                    int(value) +
                    getMaxLossAfterTrade(
                        sender,
                        optionID,
                        matchSize,
                        -matchSize * int(price)
                    ) > 0
                )
            //  (getFunds(sender, false) +              getMaxLossAfterTrade(sender, optionID, matchSize, -matchSize * int(price)) > 0)
            ) {
            return true;
        }
        return false;
    }

    function orderMatch (
        uint optionID,
        uint price,
        int size,
        uint orderID,
        uint blockExpires,
        address addr,
        uint8 v,
        bytes32 r,
        bytes32 s,
        int matchSize
    ) payable
    {
        addFundsInternal();
        bytes32 hash = sha256(
            optionID,
            price,
            size,
            orderID,
            blockExpires
        );
        //bytes32 hash = sha3(optionID, price, size, orderID, blockExpires);
        if (
                (
                    ecrecover(
                        hash,
                        v,
                        r,
                        s
                    ) == addr
                ) && 
                (block.number <= blockExpires) && 
                (
                    ((size > 0) && (matchSize < 0) && (orderFills[hash]-matchSize <= size)) || 
                    ((size < 0) && (matchSize > 0) && (orderFills[hash]-matchSize >= size))
                ) && 
                (
                    getFunds(addr, false) +
                    getMaxLossAfterTrade(
                        addr,
                        optionID,
                        -matchSize,
                        matchSize * int(price)
                    ) > 0
                ) && 
                (
                    getFunds(msg.sender, false) +
                    getMaxLossAfterTrade(
                        msg.sender,
                        optionID,
                        matchSize,
                        -matchSize * int(price)
                    ) > 0
                )
            ) {
            if (positions[msg.sender].hasPosition == false) {
                positions[msg.sender].hasPosition = true;
                numPositions++;
            }
            if (positions[addr].hasPosition == false) {
                positions[addr].hasPosition = true;
                numPositions++;
            }
            positions[msg.sender].positions[optionID] += matchSize;
            positions[msg.sender].cash -= matchSize * int(price);
            positions[addr].positions[optionID] -= matchSize;
            positions[addr].cash += matchSize * int(price);
            orderFills[hash] -= matchSize; // remember that some of market makers signed offers are already used
            OrderMatch(
                msg.sender,
                matchSize,
                addr,
                size,
                optionID,
                price
            );
        } else {
            OrderMatchFailure(
                msg.sender,
                matchSize,
                addr,
                size,
                optionID,
                price
            );
        }
    }

    function getMaxLossAfterTrade (
        address user,
        uint optionID,
        int positionChange,
        int cashChange
    ) constant returns (int)
    {

        bool maxLossInitialized = false;
        int maxLoss = 0;
        if (
            (positions[user].expired == false) &&
            (numOptions > 0)
            ) {
            for (uint s = 0; s<numOptions; s++) {
                int pnl = positions[user].cash / 1000000000000000000;
                pnl += cashChange / 1000000000000000000;
                uint settlement = 0;
                if (options[s]<0) {
                    settlement = uint(-options[s]);
                } else {
                    settlement = uint(options[s]);
                }
                pnl += moneySumAtSettlement(
                    user,
                    optionID,
                    positionChange,
                    settlement
                );
                if (pnl<maxLoss || maxLossInitialized==false) {
                    maxLossInitialized = true;
                    maxLoss = pnl;
                }
                pnl = positions[user].cash / 1000000000000000000;
                pnl += cashChange / 1000000000000000000;
                settlement = 0;
                if (options[s] < 0) {
                    if (uint(-options[s]) > margin) {
                        settlement = uint(-options[s])-margin;
                    } else {
                        settlement = 0;
                    }
                } else {
                    settlement = uint(options[s])+margin;
                }
                pnl += moneySumAtSettlement(
                    user,
                    optionID,
                    positionChange,
                    settlement
                );
                if (pnl<maxLoss) {
                    maxLoss = pnl;
                }
            }
        }
        return maxLoss;
    }

    function moneySumAtSettlement (
        address user,
        uint optionID,
        int positionChange,
        uint settlement
    ) internal returns (int)
    {
        int pnl = 0;
        for (uint j = 0; j<numOptions; j++) {
            pnl += positions[user].positions[j] * getMoneyness(options[j], settlement, margin) / 1000000000000000000;
            if (j == optionID) {
                pnl += positionChange * getMoneyness(options[j], settlement, margin) / 1000000000000000000;
            }
        }
        return pnl;
    }

}
